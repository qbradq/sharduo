package game

import (
	"io"
	"strconv"

	"github.com/qbradq/sharduo/lib/uo"
	"github.com/qbradq/sharduo/lib/uo/file"
	"github.com/qbradq/sharduo/lib/util"
)

// Map contains the tile matrix, static items, and all dynamic objects of a map.
type Map struct {
	// The chunks of the map
	chunks []*chunk
}

// NewMap creates and returns a new Map
func NewMap() *Map {
	m := &Map{
		chunks: make([]*chunk, uo.MapChunksWidth*uo.MapChunksHeight),
	}

	for cx := 0; cx < uo.MapChunksWidth; cx++ {
		for cy := 0; cy < uo.MapChunksHeight; cy++ {
			m.chunks[cy*uo.MapChunksWidth+cx] = newChunk(cx*uo.ChunkWidth, cy*uo.ChunkHeight)
		}
	}
	return m
}

// LoadFromMul reads in all of the segments of the given MapMul object and
// updates the map
func (m *Map) LoadFromMuls(mapmul *file.MapMul, staticsmul *file.StaticsMul) {
	// Load the tiles
	for iy := 0; iy < uo.MapHeight; iy++ {
		for ix := 0; ix < uo.MapWidth; ix++ {
			m.getChunk(uo.Location{X: ix, Y: iy}).setTile(ix, iy, mapmul.GetTile(ix, iy))
		}
	}
	// Load the statics
	for _, static := range staticsmul.Statics() {
		m.getChunk(static.Location).statics = append(m.getChunk(static.Location).statics, static)
	}
}

// Read reads all map properties and object references from the file. This uses
// streaming to avoid allocating a large amount of memory all at once.
func (m *Map) Read(r io.Reader) []error {
	var errs []error
	lfr := &util.ListFileReader{}
	lfr.StartReading(r)
	for {
		sname := lfr.StreamNextSegmentHeader()
		// End of file or error condition
		if sname == "" {
			break
		} else if sname == "MapChildren" {
			// Object references to all of the child objects of the map
			for {
				e := lfr.StreamNextEntry()
				// End of segment
				if e == "" {
					break
				}
				n, err := strconv.ParseInt(e, 0, 32)
				if err != nil {
					errs = append(errs, err)
					continue
				}
				o := world.Find(uo.Serial(n))
				m.getChunk(o.Location()).Add(o)
			}
		} else {
			// End of file or error
			if !lfr.SkipCurrentSegment() {
				break
			}
		}
	}
	return append(lfr.Errors(), errs...)
}

// Write writes all map object references to the file.
func (m *Map) Write(w io.WriteCloser) []error {
	lfw := util.NewListFileWriter(w)
	defer lfw.Close()

	// Write all object references of direct child objects of the map. Note that
	// we do this in a list file because using a TagFileObject would allocate
	// stupid amounts of memory when trying to load it.
	lfw.WriteComment("generated by game.Map.Write")
	lfw.WriteBlankLine()
	lfw.WriteSegmentHeader("MapChildren")
	lfw.WriteComment("items")
	for _, c := range m.chunks {
		for _, item := range c.items {
			lfw.WriteLine(item.Serial().String())
		}
	}
	lfw.WriteComment("mobiles")
	for _, c := range m.chunks {
		for _, mobile := range c.mobiles {
			lfw.WriteLine(mobile.Serial().String())
		}
	}
	lfw.WriteBlankLine()
	lfw.WriteComment("END OF FILE")
	return nil
}

// getChunk returns a pointer to the chunk for the given location.
func (m *Map) getChunk(l uo.Location) *chunk {
	l = l.WrapAndBound(l)
	cx := l.X / uo.ChunkWidth
	cy := l.Y / uo.ChunkHeight
	return m.chunks[cy*uo.MapChunksWidth+cx]
}

// GetTile returns the Tile value for the location
func (m *Map) GetTile(x, y int) uo.Tile {
	return m.getChunk(uo.Location{
		X: x,
		Y: y,
	}).GetTile(x%uo.ChunkWidth, y%uo.ChunkHeight)
}

// SetNewParent sets the parent object of this object. It properly removes
// the object from the old parent and adds the object to the new parent. Use
// nil to represent the world. This function returns false if the operation
// failed for any reason.
func (m *Map) SetNewParent(o, p Object) bool {
	oldParent := o.Parent()
	if oldParent == nil {
		if !world.Map().RemoveObject(o) {
			return false
		}
	} else {
		if !oldParent.RemoveObject(o) {
			return false
		}
	}
	o.SetParent(p)
	addFailed := false
	if p == nil {
		if !world.Map().AddObject(o) {
			addFailed = true
		}
	} else {
		if !p.AddObject(o) {
			addFailed = true
		}
	}
	if addFailed {
		// Make our best effort to not leak the object
		o.SetParent(oldParent)
		if oldParent == nil {
			world.Map().AddObject(o)
		} else {
			oldParent.AddObject(o)
		}
	}
	return true
}

// SendEverything sends everything in range to the mobile
func (m *Map) SendEverything(mob Mobile) {
	if mob.NetState() == nil {
		return
	}
	// Send items
	for _, item := range m.GetItemsInRange(mob.Location(), mob.ViewRange()) {
		mob.NetState().SendItem(item)
	}
	// Send other mobiles
	// for _, othermob := range m.GetMobilesInRange(mob.Location(), mob.ViewRange()) {
	// 	// TODO Send mobile
	// }
}

// RemoveEverything removes everything in range of the mobile
func (m *Map) RemoveEverything(mob Mobile) {
	if mob.NetState() == nil {
		return
	}
	// Remove items
	for _, item := range m.GetItemsInRange(mob.Location(), mob.ViewRange()) {
		mob.NetState().RemoveObject(item)
	}
	for _, otherMob := range m.GetMobilesInRange(mob.Location(), mob.ViewRange()) {
		mob.NetState().RemoveObject(otherMob)
	}
}

// RemoveObject removes the object from the map. It always returns true, even if
// the object was not on the map to begin with.
func (m *Map) RemoveObject(o Object) bool {
	c := m.getChunk(o.Location())
	c.Remove(o)
	// TODO Tell other mobiles with net states in range about the object removal
	// If this is a mobile with a net state we need to remove all objects
	if mob, ok := o.(Mobile); ok && mob.NetState() != nil {
		m.RemoveEverything(mob)
	}
	return true
}

// AddObject adds an object to the map sending all proper updates. It returns
// false only if the object could not fit on the map.
func (m *Map) AddObject(o Object) bool {
	c := m.getChunk(o.Location())
	// TODO Make sure there is enough room
	if !c.Add(o) {
		return false
	}
	// Send the new object to all mobiles in range with an attached net state
	mobs := m.GetMobilesInRange(o.Location(), uo.MaxViewRange)
	for _, mob := range mobs {
		if mob.NetState() == nil {
			continue
		}
		if item, ok := o.(Item); ok {
			mob.NetState().SendItem(item)
		} else if _, ok := o.(Mobile); ok {
			// TODO Send mobile
		}
	}
	// If this is a mobile with a NetState we have to send all of the items
	// and mobiles in range.
	if mob, ok := o.(Mobile); ok && mob.NetState() != nil {
		m.SendEverything(mob)
	}
	return true
}

// MoveMobile moves a mobile in the given direction. Returns true if the
// movement was successful.
func (m *Map) MoveMobile(mob Mobile, dir uo.Direction) bool {
	// Change facing request
	dir = dir.Bound().StripRunningFlag()
	if mob.Facing() != dir {
		mob.SetFacing(dir)
		return true
	}
	// Movement request
	oldLocation := mob.Location()
	newLocation := mob.Location().Forward(dir).WrapAndBound(oldLocation)
	oldChunk := m.getChunk(oldLocation)
	newChunk := m.getChunk(newLocation)
	items := m.GetItemsInRange(oldLocation, mob.ViewRange()+1)
	mobs := m.GetMobilesInRange(oldLocation, mob.ViewRange()+1)
	// If this is a mobile with an attached net state we need to check for
	// new and old objects.
	if mob.NetState() != nil {
		for _, item := range items {
			// Object used to be in range and isn't anymore, delete it
			if oldLocation.XYDistance(item.Location()) <= mob.ViewRange() &&
				newLocation.XYDistance(item.Location()) > mob.ViewRange() {
				mob.NetState().RemoveObject(item)
			} else if oldLocation.XYDistance(item.Location()) > mob.ViewRange() &&
				newLocation.XYDistance(item.Location()) <= mob.ViewRange() {
				// Object used to be out of range but is in range now, send information about it
				mob.NetState().SendItem(item)
			}
		}
	}
	// Now we need to check for attached net states that we might need to push
	// the movement to
	for _, othermob := range mobs {
		if othermob == mob || othermob.NetState() == nil {
			continue
		}
		// TODO Send movement to othermob
	}
	// Chunk updates
	if oldChunk != newChunk {
		oldChunk.Remove(mob)
	}
	// TODO Trigger events for moving off the tile
	mob.SetLocation(newLocation)
	// TODO Trigger events for moving onto the tile
	if oldChunk != newChunk {
		newChunk.Add(mob)
	}
	return true
}

// TeleportMobile moves a mobile from where it is now to the new location. This
// returns false if there is not enough room at that location for the mobile.
// This will also trigger all events as if the mobile left the tile normally,
// and arrived at the new tile normally.
func (m *Map) TeleportMobile(mob Mobile, l uo.Location) bool {
	oldLocation := mob.Location()
	world.Map().RemoveObject(mob) // This triggers on leave events
	mob.SetLocation(l)
	if !world.Map().AddObject(mob) { // This triggers on enter events
		// Best effort to not leak the mobile. Note that if we leak a player
		// mobile it will still be in the data set and will be retrieved when
		// the player logs in again.
		mob.SetLocation(oldLocation)
		world.Map().AddObject(mob)
		return false
	}
	if mob.NetState() != nil {
		mob.NetState().SendDrawPlayer()
	}
	return true
}

// getChunksInBounds returns a slice of all the chunks within a given bounds.
func (m *Map) getChunksInBounds(b uo.Bounds) []*chunk {
	var ret []*chunk
	scx := b.X / uo.ChunkWidth
	scy := b.Y / uo.ChunkHeight
	ecx := (b.X + b.W - 1) / uo.ChunkWidth
	ecy := (b.Y + b.H - 1) / uo.ChunkHeight
	for cy := scy; cy <= ecy; cy++ {
		for cx := scx; cx <= ecx; cx++ {
			ret = append(ret, m.chunks[cy*uo.MapChunksWidth+cx])
		}
	}
	return ret
}

// getChunksInRange gets chunks in the given range of a reference point.
func (m *Map) getChunksInRange(l uo.Location, r int) []*chunk {
	return m.getChunksInBounds(uo.Bounds{
		X: l.X - r,
		Y: l.Y - r,
		W: r*2 + 1,
		H: r*2 + 1,
	})
}

// GetItemsInRange returns a slice of all items within the given range of the
// given location.
func (m *Map) GetItemsInRange(l uo.Location, r int) []Item {
	var ret []Item
	for _, c := range m.getChunksInRange(l, r) {
		for _, item := range c.items {
			d := l.XYDistance(item.Location())
			if d > r {
				continue
			}
			ret = append(ret, item)
		}
	}
	return ret
}

// GetMobilesInRange returns a slice of all items within the given range of the
// given location.
func (m *Map) GetMobilesInRange(l uo.Location, r int) []Mobile {
	var ret []Mobile
	for _, c := range m.getChunksInRange(l, r) {
		for _, mob := range c.mobiles {
			d := l.XYDistance(mob.Location())
			if d > r {
				continue
			}
			ret = append(ret, mob)
		}
	}
	return ret
}

// UpdateViewRangeForMobile handles an update of the mobiles ViewRange value
// in a way that sends the correct packets to the attached NetState, if any.
func (m *Map) UpdateViewRangeForMobile(mob Mobile, r int) {
	r = uo.BoundViewRange(r)
	if r == mob.ViewRange() {
		return
	}
	if r < mob.ViewRange() {
		// Look for the set of currently-visible objects that will no longer be
		for _, item := range m.GetItemsInRange(mob.Location(), mob.ViewRange()) {
			if mob.Location().XYDistance(item.Location()) > r {
				mob.NetState().RemoveObject(item)
			}
		}
		for _, othermob := range m.GetMobilesInRange(mob.Location(), mob.ViewRange()) {
			if mob.Location().XYDistance(othermob.Location()) > r {
				mob.NetState().RemoveObject(othermob)
			}
		}
	} else {
		// Look for the set of currently-non-visible objects that will be
		for _, item := range m.GetItemsInRange(mob.Location(), r) {
			if mob.Location().XYDistance(item.Location()) > mob.ViewRange() {
				mob.NetState().SendItem(item)
			}
		}
		for _, othermob := range m.GetMobilesInRange(mob.Location(), r) {
			if mob.Location().XYDistance(othermob.Location()) > mob.ViewRange() {
				// TODO Send mobile
			}
		}
	}
	mob.SetViewRange(r)
}

// GetHighestZ returns the highest Z coordinate of a solid surface at the given
// location that has a Z altitude less than or equal to zlimit.
func (m *Map) GetTopSurface(l uo.Location, zLimit int) uo.CommonObject {
	var topObj uo.CommonObject
	zLimit = uo.BoundZ(zLimit)
	topZ := uo.MapMinZ
	c := m.getChunk(l)
	t := c.GetTile(l.X%uo.ChunkWidth, l.Y%uo.ChunkHeight)
	topObj = t
	if !t.Ignore() {
		avgZ := m.GetAverageTerrainZ(l)
		if avgZ == zLimit {
			return t
		} else if avgZ < zLimit {
			topZ = avgZ
		}
		// Else topz is still uo.MapMinZ and we are looking for statics and
		// items underground.
	}
	for _, static := range c.statics {
		// Only select surfaces
		if !static.Surface() && !static.Wet() {
			continue
		}
		staticTopZ := static.Z() + static.Height()
		if staticTopZ > topZ && staticTopZ <= zLimit {
			if staticTopZ == zLimit {
				return static
			} else {
				topZ = staticTopZ
				topObj = static
			}
		}
	}
	// TODO Check items
	return topObj
}

// GetAverageTerrainZ returns the average Z coordinate of the terrain at the
// location.
func (m *Map) GetAverageTerrainZ(l uo.Location) int {
	var ret int
	zTop := m.GetTile(l.X, l.Y).Z()
	zLeft := m.GetTile(l.X, l.Y+1).Z()
	zRight := m.GetTile(l.X+1, l.Y).Z()
	zBottom := m.GetTile(l.X+1, l.Y+1).Z()
	z := zTop
	if zLeft < z {
		z = zLeft
	}
	if zRight < z {
		z = zRight
	}
	if zBottom < z {
		z = zBottom
	}
	top := zTop
	if zLeft > top {
		top = zLeft
	}
	if zRight > top {
		top = zRight
	}
	if zBottom > top {
		top = zBottom
	}
	tbdif := zTop - zBottom
	if tbdif < 0 {
		tbdif *= -1
	}
	lrdif := zLeft - zRight
	if lrdif < 0 {
		lrdif *= -1
	}
	if tbdif > lrdif {
		ret = zLeft + zRight
	} else {
		ret = zTop + zBottom
	}
	if ret < 0 {
		ret--
	}
	return ret / 2
}
