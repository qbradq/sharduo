package clientpacket

import (
	"testing"
)

func TestPackets(t *testing.T) {
	var tests = []struct {
		id   byte
		data []byte
	}{
		{0x5D, []byte{0x5d, 0xed, 0xed, 0xed, 0xed, 0x71, 0x62, 0x72, 0x61, 0x64, 0x71, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x7f}},
		{0x73, []byte{0x73, 0x00}},
		{0x80, []byte{0x80, 0x6c, 0x61, 0x7a, 0x79, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x61, 0x73, 0x64, 0x66, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff}},
		{0x91, []byte{0x91, 0xdb, 0x1f, 0x2a, 0x70, 0x6c, 0x61, 0x7a, 0x79, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x61, 0x73, 0x64, 0x66, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}},
		{0xA0, []byte{0xa0, 0x0, 0x0}},
		{0xBD, []byte{0xbd, 0x0, 0xb, 0x35, 0x2e, 0x30, 0x2e, 0x39, 0x2e, 0x31, 0x0}},
	}

	for _, test := range tests {
		p := New(test.data)
		if _, ok := p.(*UnsupportedPacket); ok {
			t.Fatalf("Unsupported packet %X", test.id)
		}
		if test.id != p.GetID() {
			t.Fatalf("Packet %X ID mismatch", test.id)
		}
	}
}
